!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("rxjs"),require("rxjs/operators"),require("@stomp/stompjs")):"function"==typeof define&&define.amd?define("RxStomp",["rxjs","rxjs/operators","@stomp/stompjs"],t):"object"==typeof exports?exports.RxStomp=t(require("rxjs"),require("rxjs/operators"),require("@stomp/stompjs")):e.RxStomp=t(e.rxjs,e.rxjs.operators,e.StompJs)}("undefined"!=typeof self?self:this,(function(e,t,s){return(()=>{var n={458:(e,t)=>{"use strict";var s=function(){function e(){}return e.UUID=function(){if("undefined"!=typeof window&&void 0!==window.crypto&&void 0!==window.crypto.getRandomValues){var e=new Uint16Array(8);return window.crypto.getRandomValues(e),this.pad4(e[0])+this.pad4(e[1])+"-"+this.pad4(e[2])+"-"+this.pad4(e[3])+"-"+this.pad4(e[4])+"-"+this.pad4(e[5])+this.pad4(e[6])+this.pad4(e[7])}return this.random4()+this.random4()+"-"+this.random4()+"-"+this.random4()+"-"+this.random4()+"-"+this.random4()+this.random4()+this.random4()},e.pad4=function(e){for(var t=e.toString(16);t.length<4;)t="0"+t;return t},e.random4=function(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)},e}();t.h=s},131:()=>{},423:()=>{},919:(e,t,s)=>{"use strict";s.d(t,{j:()=>n});class n{}},752:(e,t,s)=>{"use strict";s.d(t,{b:()=>n});class n{}},385:(e,t,s)=>{"use strict";s.d(t,{L:()=>r});var n=s(318),i=s(443),o=s(458);class r{constructor(e,t){this.rxStomp=e,this.stompRPCConfig=t,this._replyQueueName="/temp-queue/rpc-replies",this._setupReplyQueue=()=>this.rxStomp.unhandledMessage$,this._customReplyQueue=!1,t&&(t.replyQueueName&&(this._replyQueueName=t.replyQueueName),t.setupReplyQueue&&(this._customReplyQueue=!0,this._setupReplyQueue=t.setupReplyQueue))}rpc(e){return this.stream(e).pipe((0,i.first)())}stream(e){const t=Object.assign({},e.headers||{}),{destination:s,body:r,binaryBody:u}=e;if(!this._repliesObservable){const e=this._setupReplyQueue(this._replyQueueName,this.rxStomp);this._customReplyQueue&&(this._dummySubscription=e.subscribe((()=>{}))),this._repliesObservable=e}return n.Observable.create((e=>{let n;const a=t["correlation-id"]||o.h.UUID();return n=this._repliesObservable.pipe((0,i.filter)((e=>e.headers["correlation-id"]===a))).subscribe((t=>{e.next(t)})),t["reply-to"]=this._replyQueueName,t["correlation-id"]=a,this.rxStomp.publish({destination:s,body:r,binaryBody:u,headers:t}),()=>{n.unsubscribe()}}))}}},488:(e,t,s)=>{"use strict";var n;s.d(t,{U:()=>n}),function(e){e[e.CONNECTING=0]="CONNECTING",e[e.OPEN=1]="OPEN",e[e.CLOSING=2]="CLOSING",e[e.CLOSED=3]="CLOSED"}(n||(n={}))},730:(e,t,s)=>{"use strict";s.d(t,{Y:()=>a});var n=s(318),i=s(443),o=s(102),r=s(488),u=function(e,t,s,n){return new(s||(s=Promise))((function(i,o){function r(e){try{a(n.next(e))}catch(e){o(e)}}function u(e){try{a(n.throw(e))}catch(e){o(e)}}function a(e){var t;e.done?i(e.value):(t=e.value,t instanceof s?t:new s((function(e){e(t)}))).then(r,u)}a((n=n.apply(e,t||[])).next())}))};class a{constructor(){this._queuedMessages=[],this._stompClient=new o.Client;const e=()=>{};this._beforeConnect=e,this._debug=e,this._connectionStatePre$=new n.BehaviorSubject(r.U.CLOSED),this._connectedPre$=this._connectionStatePre$.pipe((0,i.filter)((e=>e===r.U.OPEN))),this.connectionState$=new n.BehaviorSubject(r.U.CLOSED),this.connected$=this.connectionState$.pipe((0,i.filter)((e=>e===r.U.OPEN))),this.connected$.subscribe((()=>{this._sendQueuedMessages()})),this._serverHeadersBehaviourSubject$=new n.BehaviorSubject(null),this.serverHeaders$=this._serverHeadersBehaviourSubject$.pipe((0,i.filter)((e=>null!==e))),this.stompErrors$=new n.Subject,this.unhandledMessage$=new n.Subject,this.unhandledReceipts$=new n.Subject,this.unhandledFrame$=new n.Subject,this.webSocketErrors$=new n.Subject}get stompClient(){return this._stompClient}configure(e){const t=Object.assign({},e);t.beforeConnect&&(this._beforeConnect=t.beforeConnect,delete t.beforeConnect),this._stompClient.configure(t),t.debug&&(this._debug=t.debug)}activate(){this._stompClient.configure({beforeConnect:()=>u(this,void 0,void 0,(function*(){this._changeState(r.U.CONNECTING),yield this._beforeConnect(this)})),onConnect:e=>{this._serverHeadersBehaviourSubject$.next(e.headers),this._changeState(r.U.OPEN)},onStompError:e=>{this.stompErrors$.next(e)},onWebSocketClose:()=>{this._changeState(r.U.CLOSED)},onUnhandledMessage:e=>{this.unhandledMessage$.next(e)},onUnhandledReceipt:e=>{this.unhandledReceipts$.next(e)},onUnhandledFrame:e=>{this.unhandledFrame$.next(e)},onWebSocketError:e=>{this.webSocketErrors$.next(e)}}),this._stompClient.activate()}deactivate(){return u(this,void 0,void 0,(function*(){this._changeState(r.U.CLOSING),yield this._stompClient.deactivate(),this._changeState(r.U.CLOSED)}))}connected(){return this.connectionState$.getValue()===r.U.OPEN}get active(){return this.stompClient.active}publish(e){const t=null==e.retryIfDisconnected||e.retryIfDisconnected;if(this.connected())this._stompClient.publish(e);else{if(!t)throw new Error("Cannot publish while broker is not connected");this._debug("Not connected, queueing"),this._queuedMessages.push(e)}}_sendQueuedMessages(){const e=this._queuedMessages;if(this._queuedMessages=[],0!==e.length){this._debug(`Will try sending  ${e.length} queued message(s)`);for(const t of e)this._debug(`Attempting to send ${t}`),this.publish(t)}}watch(e,t={}){const s={subHeaders:{},unsubHeaders:{},subscribeOnlyOnce:!1};let o;return o="string"==typeof e?Object.assign({},s,{destination:e,subHeaders:t}):Object.assign({},s,e),this._debug(`Request to subscribe ${o.destination}`),n.Observable.create((e=>{let t,s,n=this._connectedPre$;return o.subscribeOnlyOnce&&(n=n.pipe((0,i.take)(1))),s=n.subscribe((()=>{this._debug(`Will subscribe to ${o.destination}`);let s=o.subHeaders;"function"==typeof s&&(s=s()),t=this._stompClient.subscribe(o.destination,(t=>{e.next(t)}),s)})),()=>{if(this._debug(`Stop watching connection state (for ${o.destination})`),s.unsubscribe(),this.connected()){this._debug(`Will unsubscribe from ${o.destination} at Stomp`);let e=o.unsubHeaders;"function"==typeof e&&(e=e()),t.unsubscribe(e)}else this._debug(`Stomp not connected, no need to unsubscribe from ${o.destination} at Stomp`)}})).pipe((0,i.share)())}watchForReceipt(e,t){this._stompClient.watchForReceipt(e,t)}_changeState(e){this._connectionStatePre$.next(e),this.connectionState$.next(e)}}},102:e=>{"use strict";e.exports=s},443:e=>{"use strict";e.exports=t},318:t=>{"use strict";t.exports=e}},i={};function o(e){var t=i[e];if(void 0!==t)return t.exports;var s=i[e]={exports:{}};return n[e](s,s.exports,o),s.exports}o.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return o.d(t,{a:t}),t},o.d=(e,t)=>{for(var s in t)o.o(t,s)&&!o.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),o.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r={};return(()=>{"use strict";o.r(r),o.d(r,{RxStompConfig:()=>e.j,RxStomp:()=>t.Y,RxStompState:()=>s.U,RxStompRPCConfig:()=>n.b,RxStompRPC:()=>i.L});var e=o(919),t=o(730),s=o(488),n=o(752),i=o(385),u=o(131),a={};for(const e in u)["default","RxStompConfig","RxStomp","RxStompState","RxStompRPCConfig","RxStompRPC"].indexOf(e)<0&&(a[e]=()=>u[e]);o.d(r,a);var c=o(423);a={};for(const e in c)["default","RxStompConfig","RxStomp","RxStompState","RxStompRPCConfig","RxStompRPC"].indexOf(e)<0&&(a[e]=()=>c[e]);o.d(r,a)})(),r})()}));
//# sourceMappingURL=rx-stomp.umd.min.js.map