!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("rxjs"),require("@stomp/stompjs"),require("uuid")):"function"==typeof define&&define.amd?define(["exports","rxjs","@stomp/stompjs","uuid"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).RxStomp={},e.rxjs,e.StompJs,e.uuid)}(this,(function(e,t,s,n){"use strict";var i;e.RxStompState=void 0,(i=e.RxStompState=e.RxStompState||(e.RxStompState={}))[i.CONNECTING=0]="CONNECTING",i[i.OPEN=1]="OPEN",i[i.CLOSING=2]="CLOSING",i[i.CLOSED=3]="CLOSED";Object.defineProperty(e,"StompHeaders",{enumerable:!0,get:function(){return s.StompHeaders}}),Object.defineProperty(e,"StompSocketState",{enumerable:!0,get:function(){return s.StompSocketState}}),Object.defineProperty(e,"Versions",{enumerable:!0,get:function(){return s.Versions}}),e.RxStomp=class{get stompClient(){return this._stompClient}constructor(n){this._queuedMessages=[];const i=n||new s.Client;this._stompClient=i;const r=()=>{};this._beforeConnect=r,this._correlateErrors=()=>{},this._debug=r,this._connectionStatePre$=new t.BehaviorSubject(e.RxStompState.CLOSED),this._connectedPre$=this._connectionStatePre$.pipe(t.filter((t=>t===e.RxStompState.OPEN))),this.connectionState$=new t.BehaviorSubject(e.RxStompState.CLOSED),this.connected$=this.connectionState$.pipe(t.filter((t=>t===e.RxStompState.OPEN))),this.connected$.subscribe((()=>{this._sendQueuedMessages()})),this._serverHeadersBehaviourSubject$=new t.BehaviorSubject(null),this.serverHeaders$=this._serverHeadersBehaviourSubject$.pipe(t.filter((e=>null!==e))),this.stompErrors$=new t.Subject,this.unhandledMessage$=new t.Subject,this.unhandledReceipts$=new t.Subject,this.unhandledFrame$=new t.Subject,this.webSocketErrors$=new t.Subject}configure(e){const t=Object.assign({},e);t.beforeConnect&&(this._beforeConnect=t.beforeConnect,delete t.beforeConnect),t.correlateErrors&&(this._correlateErrors=t.correlateErrors,delete t.correlateErrors),this._stompClient.configure(t),t.debug&&(this._debug=t.debug)}activate(){this._stompClient.configure({beforeConnect:async()=>{this._changeState(e.RxStompState.CONNECTING),await this._beforeConnect(this)},onConnect:t=>{this._serverHeadersBehaviourSubject$.next(t.headers),this._changeState(e.RxStompState.OPEN)},onStompError:e=>{this.stompErrors$.next(e)},onWebSocketClose:()=>{this._changeState(e.RxStompState.CLOSED)},onUnhandledMessage:e=>{this.unhandledMessage$.next(e)},onUnhandledReceipt:e=>{this.unhandledReceipts$.next(e)},onUnhandledFrame:e=>{this.unhandledFrame$.next(e)},onWebSocketError:e=>{this.webSocketErrors$.next(e)}}),this._stompClient.activate()}async deactivate(t={}){this._changeState(e.RxStompState.CLOSING),await this._stompClient.deactivate(t),this._changeState(e.RxStompState.CLOSED)}connected(){return this.connectionState$.getValue()===e.RxStompState.OPEN}get active(){return this.stompClient.active}publish(e){const t=null==e.retryIfDisconnected||e.retryIfDisconnected;if(this.connected())this._stompClient.publish(e);else{if(!t)throw new Error("Cannot publish while broker is not connected");this._debug("Not connected, queueing"),this._queuedMessages.push(e)}}_sendQueuedMessages(){const e=this._queuedMessages;if(this._queuedMessages=[],0!==e.length){this._debug(`Will try sending  ${e.length} queued message(s)`);for(const t of e)this._debug(`Attempting to send ${t}`),this.publish(t)}}watch(e,s={}){const n={subHeaders:{},unsubHeaders:{},subscribeOnlyOnce:!1};let i;i="string"==typeof e?Object.assign({},n,{destination:e,subHeaders:s}):Object.assign({},n,e),this._debug(`Request to subscribe ${i.destination}`);return t.Observable.create((e=>{let s,n,r=this._connectedPre$;i.subscribeOnlyOnce&&(r=r.pipe(t.take(1)));const o=this.stompErrors$.subscribe((t=>{this._correlateErrors(t)===i.destination&&e.error(t)}));return n=r.subscribe((()=>{this._debug(`Will subscribe to ${i.destination}`);let t=i.subHeaders;"function"==typeof t&&(t=t()),s=this._stompClient.subscribe(i.destination,(t=>{e.next(t)}),t)})),()=>{if(this._debug(`Stop watching connection state (for ${i.destination})`),n.unsubscribe(),o.unsubscribe(),this.connected()){this._debug(`Will unsubscribe from ${i.destination} at Stomp`);let e=i.unsubHeaders;"function"==typeof e&&(e=e()),s.unsubscribe(e)}else this._debug(`Stomp not connected, no need to unsubscribe from ${i.destination} at Stomp`)}})).pipe(t.share())}watchForReceipt(e,t){this._stompClient.watchForReceipt(e,t)}asyncReceipt(e){return t.firstValueFrom(this.unhandledReceipts$.pipe(t.filter((t=>t.headers["receipt-id"]===e))))}_changeState(e){this._connectionStatePre$.next(e),this.connectionState$.next(e)}},e.RxStompConfig=class{},e.RxStompRPC=class{constructor(e,t){this.rxStomp=e,this.stompRPCConfig=t,this._replyQueueName="/temp-queue/rpc-replies",this._setupReplyQueue=()=>this.rxStomp.unhandledMessage$,this._customReplyQueue=!1,t&&(t.replyQueueName&&(this._replyQueueName=t.replyQueueName),t.setupReplyQueue&&(this._customReplyQueue=!0,this._setupReplyQueue=t.setupReplyQueue))}rpc(e){return this.stream(e).pipe(t.first())}stream(e){const s={...e.headers||{}};if(!this._repliesObservable){const e=this._setupReplyQueue(this._replyQueueName,this.rxStomp);this._customReplyQueue&&(this._dummySubscription=e.subscribe((()=>{}))),this._repliesObservable=e}return t.Observable.create((i=>{let r;const o=s["correlation-id"]||n.v4();return r=this._repliesObservable.pipe(t.filter((e=>e.headers["correlation-id"]===o))).subscribe((e=>{i.next(e)})),s["reply-to"]=this._replyQueueName,s["correlation-id"]=o,this.rxStomp.publish({...e,headers:s}),()=>{r.unsubscribe()}}))}},e.RxStompRPCConfig=class{}}));
